// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wipc.proto

#ifndef PROTOBUF_wipc_2eproto__INCLUDED
#define PROTOBUF_wipc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace wipc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_wipc_2eproto();
void protobuf_AssignDesc_wipc_2eproto();
void protobuf_ShutdownFile_wipc_2eproto();

class Message;
class Screen;
class Resolution;
class Frequency;
class ImageDiff;
class Touch;
class Key;
class Button;
class Command;

enum Message_Type {
  Message_Type_SCREEN = 1,
  Message_Type_TOUCH = 2,
  Message_Type_KEY = 3,
  Message_Type_BUTTON = 4,
  Message_Type_CMD = 5
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_SCREEN;
const Message_Type Message_Type_Type_MAX = Message_Type_CMD;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor();
inline const ::std::string& Message_Type_Name(Message_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Type_descriptor(), value);
}
inline bool Message_Type_Parse(
    const ::std::string& name, Message_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
enum Screen_Type {
  Screen_Type_RESOLUTION = 1,
  Screen_Type_FREQUENCY = 2,
  Screen_Type_IMGDIFF = 3
};
bool Screen_Type_IsValid(int value);
const Screen_Type Screen_Type_Type_MIN = Screen_Type_RESOLUTION;
const Screen_Type Screen_Type_Type_MAX = Screen_Type_IMGDIFF;
const int Screen_Type_Type_ARRAYSIZE = Screen_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Screen_Type_descriptor();
inline const ::std::string& Screen_Type_Name(Screen_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Screen_Type_descriptor(), value);
}
inline bool Screen_Type_Parse(
    const ::std::string& name, Screen_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Screen_Type>(
    Screen_Type_descriptor(), name, value);
}
enum Touch_Type {
  Touch_Type_MOVE = 2,
  Touch_Type_DOWN = 1,
  Touch_Type_UP = 0
};
bool Touch_Type_IsValid(int value);
const Touch_Type Touch_Type_Type_MIN = Touch_Type_UP;
const Touch_Type Touch_Type_Type_MAX = Touch_Type_MOVE;
const int Touch_Type_Type_ARRAYSIZE = Touch_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Touch_Type_descriptor();
inline const ::std::string& Touch_Type_Name(Touch_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Touch_Type_descriptor(), value);
}
inline bool Touch_Type_Parse(
    const ::std::string& name, Touch_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Touch_Type>(
    Touch_Type_descriptor(), name, value);
}
enum Key_Type {
  Key_Type_ENABLE = 0,
  Key_Type_DISABLE = 1
};
bool Key_Type_IsValid(int value);
const Key_Type Key_Type_Type_MIN = Key_Type_ENABLE;
const Key_Type Key_Type_Type_MAX = Key_Type_DISABLE;
const int Key_Type_Type_ARRAYSIZE = Key_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Key_Type_descriptor();
inline const ::std::string& Key_Type_Name(Key_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Key_Type_descriptor(), value);
}
inline bool Key_Type_Parse(
    const ::std::string& name, Key_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Key_Type>(
    Key_Type_descriptor(), name, value);
}
enum Button_Type {
  Button_Type_UP = 0,
  Button_Type_DOWN = 1,
  Button_Type_LONGPRESS = 2
};
bool Button_Type_IsValid(int value);
const Button_Type Button_Type_Type_MIN = Button_Type_UP;
const Button_Type Button_Type_Type_MAX = Button_Type_LONGPRESS;
const int Button_Type_Type_ARRAYSIZE = Button_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Button_Type_descriptor();
inline const ::std::string& Button_Type_Name(Button_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Button_Type_descriptor(), value);
}
inline bool Button_Type_Parse(
    const ::std::string& name, Button_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Button_Type>(
    Button_Type_descriptor(), name, value);
}
enum Command_Type {
  Command_Type_HALT = 0,
  Command_Type_INIT_KEY = 1,
  Command_Type_UPDATE = 2
};
bool Command_Type_IsValid(int value);
const Command_Type Command_Type_Type_MIN = Command_Type_HALT;
const Command_Type Command_Type_Type_MAX = Command_Type_UPDATE;
const int Command_Type_Type_ARRAYSIZE = Command_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Type_descriptor();
inline const ::std::string& Command_Type_Name(Command_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Type_descriptor(), value);
}
inline bool Command_Type_Parse(
    const ::std::string& name, Command_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Type>(
    Command_Type_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_Type Type;
  static const Type SCREEN = Message_Type_SCREEN;
  static const Type TOUCH = Message_Type_TOUCH;
  static const Type KEY = Message_Type_KEY;
  static const Type BUTTON = Message_Type_BUTTON;
  static const Type CMD = Message_Type_CMD;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Message_Type_Type_MIN;
  static const Type Type_MAX =
    Message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Message_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .wipc.Message.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::wipc::Message_Type type() const;
  inline void set_type(::wipc::Message_Type value);

  // repeated .wipc.Touch touch = 2;
  inline int touch_size() const;
  inline void clear_touch();
  static const int kTouchFieldNumber = 2;
  inline const ::wipc::Touch& touch(int index) const;
  inline ::wipc::Touch* mutable_touch(int index);
  inline ::wipc::Touch* add_touch();
  inline const ::google::protobuf::RepeatedPtrField< ::wipc::Touch >&
      touch() const;
  inline ::google::protobuf::RepeatedPtrField< ::wipc::Touch >*
      mutable_touch();

  // optional .wipc.Screen screen = 3;
  inline bool has_screen() const;
  inline void clear_screen();
  static const int kScreenFieldNumber = 3;
  inline const ::wipc::Screen& screen() const;
  inline ::wipc::Screen* mutable_screen();
  inline ::wipc::Screen* release_screen();
  inline void set_allocated_screen(::wipc::Screen* screen);

  // optional .wipc.Key key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::wipc::Key& key() const;
  inline ::wipc::Key* mutable_key();
  inline ::wipc::Key* release_key();
  inline void set_allocated_key(::wipc::Key* key);

  // optional .wipc.Button button = 5;
  inline bool has_button() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 5;
  inline const ::wipc::Button& button() const;
  inline ::wipc::Button* mutable_button();
  inline ::wipc::Button* release_button();
  inline void set_allocated_button(::wipc::Button* button);

  // optional .wipc.Command command = 6;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 6;
  inline const ::wipc::Command& command() const;
  inline ::wipc::Command* mutable_command();
  inline ::wipc::Command* release_command();
  inline void set_allocated_command(::wipc::Command* command);

  // @@protoc_insertion_point(class_scope:wipc.Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_screen();
  inline void clear_has_screen();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_button();
  inline void clear_has_button();
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::wipc::Touch > touch_;
  ::wipc::Screen* screen_;
  ::wipc::Key* key_;
  ::wipc::Button* button_;
  ::wipc::Command* command_;
  int type_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Screen : public ::google::protobuf::Message {
 public:
  Screen();
  virtual ~Screen();

  Screen(const Screen& from);

  inline Screen& operator=(const Screen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Screen& default_instance();

  void Swap(Screen* other);

  // implements Message ----------------------------------------------

  Screen* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Screen& from);
  void MergeFrom(const Screen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Screen_Type Type;
  static const Type RESOLUTION = Screen_Type_RESOLUTION;
  static const Type FREQUENCY = Screen_Type_FREQUENCY;
  static const Type IMGDIFF = Screen_Type_IMGDIFF;
  static inline bool Type_IsValid(int value) {
    return Screen_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Screen_Type_Type_MIN;
  static const Type Type_MAX =
    Screen_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Screen_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Screen_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Screen_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Screen_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .wipc.Screen.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::wipc::Screen_Type type() const;
  inline void set_type(::wipc::Screen_Type value);

  // optional .wipc.Resolution resolution = 2;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 2;
  inline const ::wipc::Resolution& resolution() const;
  inline ::wipc::Resolution* mutable_resolution();
  inline ::wipc::Resolution* release_resolution();
  inline void set_allocated_resolution(::wipc::Resolution* resolution);

  // optional .wipc.Frequency frequency = 3;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  inline const ::wipc::Frequency& frequency() const;
  inline ::wipc::Frequency* mutable_frequency();
  inline ::wipc::Frequency* release_frequency();
  inline void set_allocated_frequency(::wipc::Frequency* frequency);

  // optional .wipc.ImageDiff imagediff = 4;
  inline bool has_imagediff() const;
  inline void clear_imagediff();
  static const int kImagediffFieldNumber = 4;
  inline const ::wipc::ImageDiff& imagediff() const;
  inline ::wipc::ImageDiff* mutable_imagediff();
  inline ::wipc::ImageDiff* release_imagediff();
  inline void set_allocated_imagediff(::wipc::ImageDiff* imagediff);

  // @@protoc_insertion_point(class_scope:wipc.Screen)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_imagediff();
  inline void clear_has_imagediff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::wipc::Resolution* resolution_;
  ::wipc::Frequency* frequency_;
  ::wipc::ImageDiff* imagediff_;
  int type_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static Screen* default_instance_;
};
// -------------------------------------------------------------------

class Resolution : public ::google::protobuf::Message {
 public:
  Resolution();
  virtual ~Resolution();

  Resolution(const Resolution& from);

  inline Resolution& operator=(const Resolution& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resolution& default_instance();

  void Swap(Resolution* other);

  // implements Message ----------------------------------------------

  Resolution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resolution& from);
  void MergeFrom(const Resolution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:wipc.Resolution)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static Resolution* default_instance_;
};
// -------------------------------------------------------------------

class Frequency : public ::google::protobuf::Message {
 public:
  Frequency();
  virtual ~Frequency();

  Frequency(const Frequency& from);

  inline Frequency& operator=(const Frequency& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Frequency& default_instance();

  void Swap(Frequency* other);

  // implements Message ----------------------------------------------

  Frequency* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Frequency& from);
  void MergeFrom(const Frequency& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 frequency = 1;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  inline ::google::protobuf::uint32 frequency() const;
  inline void set_frequency(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:wipc.Frequency)
 private:
  inline void set_has_frequency();
  inline void clear_has_frequency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 frequency_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static Frequency* default_instance_;
};
// -------------------------------------------------------------------

class ImageDiff : public ::google::protobuf::Message {
 public:
  ImageDiff();
  virtual ~ImageDiff();

  ImageDiff(const ImageDiff& from);

  inline ImageDiff& operator=(const ImageDiff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageDiff& default_instance();

  void Swap(ImageDiff* other);

  // implements Message ----------------------------------------------

  ImageDiff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageDiff& from);
  void MergeFrom(const ImageDiff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool diff = 1;
  inline bool has_diff() const;
  inline void clear_diff();
  static const int kDiffFieldNumber = 1;
  inline bool diff() const;
  inline void set_diff(bool value);

  // @@protoc_insertion_point(class_scope:wipc.ImageDiff)
 private:
  inline void set_has_diff();
  inline void clear_has_diff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool diff_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static ImageDiff* default_instance_;
};
// -------------------------------------------------------------------

class Touch : public ::google::protobuf::Message {
 public:
  Touch();
  virtual ~Touch();

  Touch(const Touch& from);

  inline Touch& operator=(const Touch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Touch& default_instance();

  void Swap(Touch* other);

  // implements Message ----------------------------------------------

  Touch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Touch& from);
  void MergeFrom(const Touch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Touch_Type Type;
  static const Type MOVE = Touch_Type_MOVE;
  static const Type DOWN = Touch_Type_DOWN;
  static const Type UP = Touch_Type_UP;
  static inline bool Type_IsValid(int value) {
    return Touch_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Touch_Type_Type_MIN;
  static const Type Type_MAX =
    Touch_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Touch_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Touch_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Touch_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Touch_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .wipc.Touch.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::wipc::Touch_Type type() const;
  inline void set_type(::wipc::Touch_Type value);

  // required uint32 width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // required bool mirror = 4;
  inline bool has_mirror() const;
  inline void clear_mirror();
  static const int kMirrorFieldNumber = 4;
  inline bool mirror() const;
  inline void set_mirror(bool value);

  // required bool flip = 5;
  inline bool has_flip() const;
  inline void clear_flip();
  static const int kFlipFieldNumber = 5;
  inline bool flip() const;
  inline void set_flip(bool value);

  // @@protoc_insertion_point(class_scope:wipc.Touch)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_mirror();
  inline void clear_has_mirror();
  inline void set_has_flip();
  inline void clear_has_flip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  bool mirror_;
  bool flip_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static Touch* default_instance_;
};
// -------------------------------------------------------------------

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();

  Key(const Key& from);

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();

  void Swap(Key* other);

  // implements Message ----------------------------------------------

  Key* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Key_Type Type;
  static const Type ENABLE = Key_Type_ENABLE;
  static const Type DISABLE = Key_Type_DISABLE;
  static inline bool Type_IsValid(int value) {
    return Key_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Key_Type_Type_MIN;
  static const Type Type_MAX =
    Key_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Key_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Key_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Key_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Key_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .wipc.Key.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::wipc::Key_Type type() const;
  inline void set_type(::wipc::Key_Type value);

  // optional string defaultInputMethod = 2;
  inline bool has_defaultinputmethod() const;
  inline void clear_defaultinputmethod();
  static const int kDefaultInputMethodFieldNumber = 2;
  inline const ::std::string& defaultinputmethod() const;
  inline void set_defaultinputmethod(const ::std::string& value);
  inline void set_defaultinputmethod(const char* value);
  inline void set_defaultinputmethod(const char* value, size_t size);
  inline ::std::string* mutable_defaultinputmethod();
  inline ::std::string* release_defaultinputmethod();
  inline void set_allocated_defaultinputmethod(::std::string* defaultinputmethod);

  // @@protoc_insertion_point(class_scope:wipc.Key)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_defaultinputmethod();
  inline void clear_has_defaultinputmethod();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* defaultinputmethod_;
  int type_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// -------------------------------------------------------------------

class Button : public ::google::protobuf::Message {
 public:
  Button();
  virtual ~Button();

  Button(const Button& from);

  inline Button& operator=(const Button& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Button& default_instance();

  void Swap(Button* other);

  // implements Message ----------------------------------------------

  Button* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Button& from);
  void MergeFrom(const Button& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Button_Type Type;
  static const Type UP = Button_Type_UP;
  static const Type DOWN = Button_Type_DOWN;
  static const Type LONGPRESS = Button_Type_LONGPRESS;
  static inline bool Type_IsValid(int value) {
    return Button_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Button_Type_Type_MIN;
  static const Type Type_MAX =
    Button_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Button_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Button_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Button_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Button_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .wipc.Button.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::wipc::Button_Type type() const;
  inline void set_type(::wipc::Button_Type value);

  // required uint32 buttonid = 2;
  inline bool has_buttonid() const;
  inline void clear_buttonid();
  static const int kButtonidFieldNumber = 2;
  inline ::google::protobuf::uint32 buttonid() const;
  inline void set_buttonid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:wipc.Button)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_buttonid();
  inline void clear_has_buttonid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 buttonid_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static Button* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_Type Type;
  static const Type HALT = Command_Type_HALT;
  static const Type INIT_KEY = Command_Type_INIT_KEY;
  static const Type UPDATE = Command_Type_UPDATE;
  static inline bool Type_IsValid(int value) {
    return Command_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Command_Type_Type_MIN;
  static const Type Type_MAX =
    Command_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Command_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Command_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Command_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Command_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .wipc.Command.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::wipc::Command_Type type() const;
  inline void set_type(::wipc::Command_Type value);

  // optional string initkey = 2;
  inline bool has_initkey() const;
  inline void clear_initkey();
  static const int kInitkeyFieldNumber = 2;
  inline const ::std::string& initkey() const;
  inline void set_initkey(const ::std::string& value);
  inline void set_initkey(const char* value);
  inline void set_initkey(const char* value, size_t size);
  inline ::std::string* mutable_initkey();
  inline ::std::string* release_initkey();
  inline void set_allocated_initkey(::std::string* initkey);

  // @@protoc_insertion_point(class_scope:wipc.Command)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_initkey();
  inline void clear_has_initkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* initkey_;
  int type_;
  friend void  protobuf_AddDesc_wipc_2eproto();
  friend void protobuf_AssignDesc_wipc_2eproto();
  friend void protobuf_ShutdownFile_wipc_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// ===================================================================


// ===================================================================

// Message

// required .wipc.Message.Type type = 1;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::wipc::Message_Type Message::type() const {
  // @@protoc_insertion_point(field_get:wipc.Message.type)
  return static_cast< ::wipc::Message_Type >(type_);
}
inline void Message::set_type(::wipc::Message_Type value) {
  assert(::wipc::Message_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:wipc.Message.type)
}

// repeated .wipc.Touch touch = 2;
inline int Message::touch_size() const {
  return touch_.size();
}
inline void Message::clear_touch() {
  touch_.Clear();
}
inline const ::wipc::Touch& Message::touch(int index) const {
  // @@protoc_insertion_point(field_get:wipc.Message.touch)
  return touch_.Get(index);
}
inline ::wipc::Touch* Message::mutable_touch(int index) {
  // @@protoc_insertion_point(field_mutable:wipc.Message.touch)
  return touch_.Mutable(index);
}
inline ::wipc::Touch* Message::add_touch() {
  // @@protoc_insertion_point(field_add:wipc.Message.touch)
  return touch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wipc::Touch >&
Message::touch() const {
  // @@protoc_insertion_point(field_list:wipc.Message.touch)
  return touch_;
}
inline ::google::protobuf::RepeatedPtrField< ::wipc::Touch >*
Message::mutable_touch() {
  // @@protoc_insertion_point(field_mutable_list:wipc.Message.touch)
  return &touch_;
}

// optional .wipc.Screen screen = 3;
inline bool Message::has_screen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_screen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_screen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_screen() {
  if (screen_ != NULL) screen_->::wipc::Screen::Clear();
  clear_has_screen();
}
inline const ::wipc::Screen& Message::screen() const {
  // @@protoc_insertion_point(field_get:wipc.Message.screen)
  return screen_ != NULL ? *screen_ : *default_instance_->screen_;
}
inline ::wipc::Screen* Message::mutable_screen() {
  set_has_screen();
  if (screen_ == NULL) screen_ = new ::wipc::Screen;
  // @@protoc_insertion_point(field_mutable:wipc.Message.screen)
  return screen_;
}
inline ::wipc::Screen* Message::release_screen() {
  clear_has_screen();
  ::wipc::Screen* temp = screen_;
  screen_ = NULL;
  return temp;
}
inline void Message::set_allocated_screen(::wipc::Screen* screen) {
  delete screen_;
  screen_ = screen;
  if (screen) {
    set_has_screen();
  } else {
    clear_has_screen();
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Message.screen)
}

// optional .wipc.Key key = 4;
inline bool Message::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_key() {
  if (key_ != NULL) key_->::wipc::Key::Clear();
  clear_has_key();
}
inline const ::wipc::Key& Message::key() const {
  // @@protoc_insertion_point(field_get:wipc.Message.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::wipc::Key* Message::mutable_key() {
  set_has_key();
  if (key_ == NULL) key_ = new ::wipc::Key;
  // @@protoc_insertion_point(field_mutable:wipc.Message.key)
  return key_;
}
inline ::wipc::Key* Message::release_key() {
  clear_has_key();
  ::wipc::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void Message::set_allocated_key(::wipc::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Message.key)
}

// optional .wipc.Button button = 5;
inline bool Message::has_button() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_button() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_button() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_button() {
  if (button_ != NULL) button_->::wipc::Button::Clear();
  clear_has_button();
}
inline const ::wipc::Button& Message::button() const {
  // @@protoc_insertion_point(field_get:wipc.Message.button)
  return button_ != NULL ? *button_ : *default_instance_->button_;
}
inline ::wipc::Button* Message::mutable_button() {
  set_has_button();
  if (button_ == NULL) button_ = new ::wipc::Button;
  // @@protoc_insertion_point(field_mutable:wipc.Message.button)
  return button_;
}
inline ::wipc::Button* Message::release_button() {
  clear_has_button();
  ::wipc::Button* temp = button_;
  button_ = NULL;
  return temp;
}
inline void Message::set_allocated_button(::wipc::Button* button) {
  delete button_;
  button_ = button;
  if (button) {
    set_has_button();
  } else {
    clear_has_button();
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Message.button)
}

// optional .wipc.Command command = 6;
inline bool Message::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_command() {
  if (command_ != NULL) command_->::wipc::Command::Clear();
  clear_has_command();
}
inline const ::wipc::Command& Message::command() const {
  // @@protoc_insertion_point(field_get:wipc.Message.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::wipc::Command* Message::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::wipc::Command;
  // @@protoc_insertion_point(field_mutable:wipc.Message.command)
  return command_;
}
inline ::wipc::Command* Message::release_command() {
  clear_has_command();
  ::wipc::Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Message::set_allocated_command(::wipc::Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Message.command)
}

// -------------------------------------------------------------------

// Screen

// required .wipc.Screen.Type type = 1;
inline bool Screen::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Screen::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Screen::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Screen::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::wipc::Screen_Type Screen::type() const {
  // @@protoc_insertion_point(field_get:wipc.Screen.type)
  return static_cast< ::wipc::Screen_Type >(type_);
}
inline void Screen::set_type(::wipc::Screen_Type value) {
  assert(::wipc::Screen_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:wipc.Screen.type)
}

// optional .wipc.Resolution resolution = 2;
inline bool Screen::has_resolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Screen::set_has_resolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Screen::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Screen::clear_resolution() {
  if (resolution_ != NULL) resolution_->::wipc::Resolution::Clear();
  clear_has_resolution();
}
inline const ::wipc::Resolution& Screen::resolution() const {
  // @@protoc_insertion_point(field_get:wipc.Screen.resolution)
  return resolution_ != NULL ? *resolution_ : *default_instance_->resolution_;
}
inline ::wipc::Resolution* Screen::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == NULL) resolution_ = new ::wipc::Resolution;
  // @@protoc_insertion_point(field_mutable:wipc.Screen.resolution)
  return resolution_;
}
inline ::wipc::Resolution* Screen::release_resolution() {
  clear_has_resolution();
  ::wipc::Resolution* temp = resolution_;
  resolution_ = NULL;
  return temp;
}
inline void Screen::set_allocated_resolution(::wipc::Resolution* resolution) {
  delete resolution_;
  resolution_ = resolution;
  if (resolution) {
    set_has_resolution();
  } else {
    clear_has_resolution();
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Screen.resolution)
}

// optional .wipc.Frequency frequency = 3;
inline bool Screen::has_frequency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Screen::set_has_frequency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Screen::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Screen::clear_frequency() {
  if (frequency_ != NULL) frequency_->::wipc::Frequency::Clear();
  clear_has_frequency();
}
inline const ::wipc::Frequency& Screen::frequency() const {
  // @@protoc_insertion_point(field_get:wipc.Screen.frequency)
  return frequency_ != NULL ? *frequency_ : *default_instance_->frequency_;
}
inline ::wipc::Frequency* Screen::mutable_frequency() {
  set_has_frequency();
  if (frequency_ == NULL) frequency_ = new ::wipc::Frequency;
  // @@protoc_insertion_point(field_mutable:wipc.Screen.frequency)
  return frequency_;
}
inline ::wipc::Frequency* Screen::release_frequency() {
  clear_has_frequency();
  ::wipc::Frequency* temp = frequency_;
  frequency_ = NULL;
  return temp;
}
inline void Screen::set_allocated_frequency(::wipc::Frequency* frequency) {
  delete frequency_;
  frequency_ = frequency;
  if (frequency) {
    set_has_frequency();
  } else {
    clear_has_frequency();
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Screen.frequency)
}

// optional .wipc.ImageDiff imagediff = 4;
inline bool Screen::has_imagediff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Screen::set_has_imagediff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Screen::clear_has_imagediff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Screen::clear_imagediff() {
  if (imagediff_ != NULL) imagediff_->::wipc::ImageDiff::Clear();
  clear_has_imagediff();
}
inline const ::wipc::ImageDiff& Screen::imagediff() const {
  // @@protoc_insertion_point(field_get:wipc.Screen.imagediff)
  return imagediff_ != NULL ? *imagediff_ : *default_instance_->imagediff_;
}
inline ::wipc::ImageDiff* Screen::mutable_imagediff() {
  set_has_imagediff();
  if (imagediff_ == NULL) imagediff_ = new ::wipc::ImageDiff;
  // @@protoc_insertion_point(field_mutable:wipc.Screen.imagediff)
  return imagediff_;
}
inline ::wipc::ImageDiff* Screen::release_imagediff() {
  clear_has_imagediff();
  ::wipc::ImageDiff* temp = imagediff_;
  imagediff_ = NULL;
  return temp;
}
inline void Screen::set_allocated_imagediff(::wipc::ImageDiff* imagediff) {
  delete imagediff_;
  imagediff_ = imagediff;
  if (imagediff) {
    set_has_imagediff();
  } else {
    clear_has_imagediff();
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Screen.imagediff)
}

// -------------------------------------------------------------------

// Resolution

// required uint32 width = 1;
inline bool Resolution::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resolution::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resolution::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resolution::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Resolution::width() const {
  // @@protoc_insertion_point(field_get:wipc.Resolution.width)
  return width_;
}
inline void Resolution::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:wipc.Resolution.width)
}

// required uint32 height = 2;
inline bool Resolution::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resolution::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resolution::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resolution::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Resolution::height() const {
  // @@protoc_insertion_point(field_get:wipc.Resolution.height)
  return height_;
}
inline void Resolution::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:wipc.Resolution.height)
}

// -------------------------------------------------------------------

// Frequency

// required uint32 frequency = 1;
inline bool Frequency::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frequency::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frequency::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frequency::clear_frequency() {
  frequency_ = 0u;
  clear_has_frequency();
}
inline ::google::protobuf::uint32 Frequency::frequency() const {
  // @@protoc_insertion_point(field_get:wipc.Frequency.frequency)
  return frequency_;
}
inline void Frequency::set_frequency(::google::protobuf::uint32 value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:wipc.Frequency.frequency)
}

// -------------------------------------------------------------------

// ImageDiff

// required bool diff = 1;
inline bool ImageDiff::has_diff() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageDiff::set_has_diff() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageDiff::clear_has_diff() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageDiff::clear_diff() {
  diff_ = false;
  clear_has_diff();
}
inline bool ImageDiff::diff() const {
  // @@protoc_insertion_point(field_get:wipc.ImageDiff.diff)
  return diff_;
}
inline void ImageDiff::set_diff(bool value) {
  set_has_diff();
  diff_ = value;
  // @@protoc_insertion_point(field_set:wipc.ImageDiff.diff)
}

// -------------------------------------------------------------------

// Touch

// required .wipc.Touch.Type type = 1;
inline bool Touch::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Touch::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Touch::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Touch::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::wipc::Touch_Type Touch::type() const {
  // @@protoc_insertion_point(field_get:wipc.Touch.type)
  return static_cast< ::wipc::Touch_Type >(type_);
}
inline void Touch::set_type(::wipc::Touch_Type value) {
  assert(::wipc::Touch_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:wipc.Touch.type)
}

// required uint32 width = 2;
inline bool Touch::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Touch::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Touch::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Touch::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Touch::width() const {
  // @@protoc_insertion_point(field_get:wipc.Touch.width)
  return width_;
}
inline void Touch::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:wipc.Touch.width)
}

// required uint32 height = 3;
inline bool Touch::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Touch::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Touch::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Touch::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Touch::height() const {
  // @@protoc_insertion_point(field_get:wipc.Touch.height)
  return height_;
}
inline void Touch::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:wipc.Touch.height)
}

// required bool mirror = 4;
inline bool Touch::has_mirror() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Touch::set_has_mirror() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Touch::clear_has_mirror() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Touch::clear_mirror() {
  mirror_ = false;
  clear_has_mirror();
}
inline bool Touch::mirror() const {
  // @@protoc_insertion_point(field_get:wipc.Touch.mirror)
  return mirror_;
}
inline void Touch::set_mirror(bool value) {
  set_has_mirror();
  mirror_ = value;
  // @@protoc_insertion_point(field_set:wipc.Touch.mirror)
}

// required bool flip = 5;
inline bool Touch::has_flip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Touch::set_has_flip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Touch::clear_has_flip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Touch::clear_flip() {
  flip_ = false;
  clear_has_flip();
}
inline bool Touch::flip() const {
  // @@protoc_insertion_point(field_get:wipc.Touch.flip)
  return flip_;
}
inline void Touch::set_flip(bool value) {
  set_has_flip();
  flip_ = value;
  // @@protoc_insertion_point(field_set:wipc.Touch.flip)
}

// -------------------------------------------------------------------

// Key

// required .wipc.Key.Type type = 1;
inline bool Key::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Key::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Key::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Key::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::wipc::Key_Type Key::type() const {
  // @@protoc_insertion_point(field_get:wipc.Key.type)
  return static_cast< ::wipc::Key_Type >(type_);
}
inline void Key::set_type(::wipc::Key_Type value) {
  assert(::wipc::Key_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:wipc.Key.type)
}

// optional string defaultInputMethod = 2;
inline bool Key::has_defaultinputmethod() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Key::set_has_defaultinputmethod() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Key::clear_has_defaultinputmethod() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Key::clear_defaultinputmethod() {
  if (defaultinputmethod_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultinputmethod_->clear();
  }
  clear_has_defaultinputmethod();
}
inline const ::std::string& Key::defaultinputmethod() const {
  // @@protoc_insertion_point(field_get:wipc.Key.defaultInputMethod)
  return *defaultinputmethod_;
}
inline void Key::set_defaultinputmethod(const ::std::string& value) {
  set_has_defaultinputmethod();
  if (defaultinputmethod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultinputmethod_ = new ::std::string;
  }
  defaultinputmethod_->assign(value);
  // @@protoc_insertion_point(field_set:wipc.Key.defaultInputMethod)
}
inline void Key::set_defaultinputmethod(const char* value) {
  set_has_defaultinputmethod();
  if (defaultinputmethod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultinputmethod_ = new ::std::string;
  }
  defaultinputmethod_->assign(value);
  // @@protoc_insertion_point(field_set_char:wipc.Key.defaultInputMethod)
}
inline void Key::set_defaultinputmethod(const char* value, size_t size) {
  set_has_defaultinputmethod();
  if (defaultinputmethod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultinputmethod_ = new ::std::string;
  }
  defaultinputmethod_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:wipc.Key.defaultInputMethod)
}
inline ::std::string* Key::mutable_defaultinputmethod() {
  set_has_defaultinputmethod();
  if (defaultinputmethod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defaultinputmethod_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:wipc.Key.defaultInputMethod)
  return defaultinputmethod_;
}
inline ::std::string* Key::release_defaultinputmethod() {
  clear_has_defaultinputmethod();
  if (defaultinputmethod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = defaultinputmethod_;
    defaultinputmethod_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Key::set_allocated_defaultinputmethod(::std::string* defaultinputmethod) {
  if (defaultinputmethod_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete defaultinputmethod_;
  }
  if (defaultinputmethod) {
    set_has_defaultinputmethod();
    defaultinputmethod_ = defaultinputmethod;
  } else {
    clear_has_defaultinputmethod();
    defaultinputmethod_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Key.defaultInputMethod)
}

// -------------------------------------------------------------------

// Button

// required .wipc.Button.Type type = 1;
inline bool Button::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Button::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Button::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Button::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::wipc::Button_Type Button::type() const {
  // @@protoc_insertion_point(field_get:wipc.Button.type)
  return static_cast< ::wipc::Button_Type >(type_);
}
inline void Button::set_type(::wipc::Button_Type value) {
  assert(::wipc::Button_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:wipc.Button.type)
}

// required uint32 buttonid = 2;
inline bool Button::has_buttonid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Button::set_has_buttonid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Button::clear_has_buttonid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Button::clear_buttonid() {
  buttonid_ = 0u;
  clear_has_buttonid();
}
inline ::google::protobuf::uint32 Button::buttonid() const {
  // @@protoc_insertion_point(field_get:wipc.Button.buttonid)
  return buttonid_;
}
inline void Button::set_buttonid(::google::protobuf::uint32 value) {
  set_has_buttonid();
  buttonid_ = value;
  // @@protoc_insertion_point(field_set:wipc.Button.buttonid)
}

// -------------------------------------------------------------------

// Command

// required .wipc.Command.Type type = 1;
inline bool Command::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::wipc::Command_Type Command::type() const {
  // @@protoc_insertion_point(field_get:wipc.Command.type)
  return static_cast< ::wipc::Command_Type >(type_);
}
inline void Command::set_type(::wipc::Command_Type value) {
  assert(::wipc::Command_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:wipc.Command.type)
}

// optional string initkey = 2;
inline bool Command::has_initkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_initkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_initkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_initkey() {
  if (initkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initkey_->clear();
  }
  clear_has_initkey();
}
inline const ::std::string& Command::initkey() const {
  // @@protoc_insertion_point(field_get:wipc.Command.initkey)
  return *initkey_;
}
inline void Command::set_initkey(const ::std::string& value) {
  set_has_initkey();
  if (initkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initkey_ = new ::std::string;
  }
  initkey_->assign(value);
  // @@protoc_insertion_point(field_set:wipc.Command.initkey)
}
inline void Command::set_initkey(const char* value) {
  set_has_initkey();
  if (initkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initkey_ = new ::std::string;
  }
  initkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:wipc.Command.initkey)
}
inline void Command::set_initkey(const char* value, size_t size) {
  set_has_initkey();
  if (initkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initkey_ = new ::std::string;
  }
  initkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:wipc.Command.initkey)
}
inline ::std::string* Command::mutable_initkey() {
  set_has_initkey();
  if (initkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:wipc.Command.initkey)
  return initkey_;
}
inline ::std::string* Command::release_initkey() {
  clear_has_initkey();
  if (initkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = initkey_;
    initkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Command::set_allocated_initkey(::std::string* initkey) {
  if (initkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete initkey_;
  }
  if (initkey) {
    set_has_initkey();
    initkey_ = initkey;
  } else {
    clear_has_initkey();
    initkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:wipc.Command.initkey)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace wipc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::wipc::Message_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wipc::Message_Type>() {
  return ::wipc::Message_Type_descriptor();
}
template <> struct is_proto_enum< ::wipc::Screen_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wipc::Screen_Type>() {
  return ::wipc::Screen_Type_descriptor();
}
template <> struct is_proto_enum< ::wipc::Touch_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wipc::Touch_Type>() {
  return ::wipc::Touch_Type_descriptor();
}
template <> struct is_proto_enum< ::wipc::Key_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wipc::Key_Type>() {
  return ::wipc::Key_Type_descriptor();
}
template <> struct is_proto_enum< ::wipc::Button_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wipc::Button_Type>() {
  return ::wipc::Button_Type_descriptor();
}
template <> struct is_proto_enum< ::wipc::Command_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wipc::Command_Type>() {
  return ::wipc::Command_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_wipc_2eproto__INCLUDED
